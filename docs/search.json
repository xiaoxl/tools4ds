[
  {
    "objectID": "contents/pyconcepts/concepts.html#language",
    "href": "contents/pyconcepts/concepts.html#language",
    "title": "4  Some Hard Python concepts",
    "section": "4.1 Language",
    "text": "4.1 Language\nPython is a programming language. In other words, it is a collection of syntaxes.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/concepts.html#interpreters",
    "href": "contents/pyconcepts/concepts.html#interpreters",
    "title": "4  Some Hard Python concepts",
    "section": "4.2 Interpreters",
    "text": "4.2 Interpreters\nPython needs to be interpreted into codes that computers can understand. Therefore there should be some programs that translate Python scripts. These programs are called interpreters.\nCPython is the refernce interpreter of Python programming language, and it is the most widely used ones for Python. It is written in C and Python. When Python programming language introduces new features, they are developed based on CPython, and are first implemented in CPython. Sometimes an interpreter is also called an implementation.\nThere are alternatives to CPython, like PyPy, Jython, IronPython, etc.. In theory, any Python scripts should be able to run on any of these implementations, and the result should be the same. The differences mainly come from perfamance and compatiblity with non-Python packages. For example, CPython is executed by a C interpreter. Therefore it is very easy to write C-extensions for your Python code. Jython, since it is implemented in Java, makes it very easy to work with other Java programs that you can import any Java classes with no additional effort.\nSince CPython is most-widely used and tested, it is the best choice, at least for beginners. And actually, if you have no idea about this topic, but you use Python, it is highly possible that you are using CPython.\n\n\n\n\n\n\nNote\n\n\n\n\n\nWe mentioned “interpreter” here. There are mainly two types of implimentations of programming langauges: interpreters and compilers. There are also some additional types like just-in-time compilers which can be treated as combinations of the two.\nPython is usually treated as an interpreted language since CPython is an interpreter. One of Python’s most useful features is its interactive interpreter, which allows for very fast testing of ideas without the overhead of creating test files as is typical in most programming languages.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/concepts.html#repl",
    "href": "contents/pyconcepts/concepts.html#repl",
    "title": "4  Some Hard Python concepts",
    "section": "4.3 REPL",
    "text": "4.3 REPL\nThere are two ways to use Python interpreter. The default way is that Python interpreter reads a file and execute a script from there. The second way is called the intereactive shell, that Python interpreter read the input from user directly, and print the result immediately. The model is like code example: prompt the user for some code, and when they’ve entered it, execute it in the same process. This model is often called a REPL, or Read-Eval-Print-Loop.\nShell, terminal, console have different meanings in their original contexts. However, nowadays, especially when talking about Python intereactive shell, these terminologies are used interchangeably. They are referred to the frontend of the system. In other words, the main task for the Python intereactive shell is to handle the user inputs and communicate with the backend, which is also called a kernel. We won’t distinguish the real differences between these terminologies. The kernel will be discussed in the next section.\nThe standard interactive Python interpreter can be invoked on the command line with the python command. Note that you should make sure that the PATH system enviroment variable is configured, otherwise you have to specifiy the path to the Python execuatable file. To quit the intereactive shell you can type the commands quit()/exit()/Ctrl+Z then Enter.\n\n\n\n\n\n\nNote\n\n\n\nIn the REPL model, the backend (evaluation) is basically handled by the Python interpreter. The frontend is dealing with the user interface. Some typically tasks include the primary/secondary prompt and multi-line commands. The original REPL is very limited.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/concepts.html#ipython",
    "href": "contents/pyconcepts/concepts.html#ipython",
    "title": "4  Some Hard Python concepts",
    "section": "4.4 IPython",
    "text": "4.4 IPython\nIPython was initially designed as an Enhanced interactive Python shell. However after many year’s development, the whole IPython project becomes too big to maintain as one single project. Therefore it is now split into many smaller projects. The two most popular projects are IPython and Jupyter. This is called the Big Split.\nThe current IPython play two fundamental roles:\n\nTerminal IPython as the familiar REPL;\nThe IPython kernel (which is defined below) that provides computation and communication with the frontend interfaces, like the notebook.\n\nThe core idea in the design of IPython is to abstract and extend the notion of a traditional REPL environment by decoupling the evaluation into its own process. We call this process a kernel: it receives execution instructions from clients and communicates the results back to them.\nThis decoupling allows us to have several clients connected to the same kernel, and even allows clients and kernels to live on different machines. This two-process model is now used by most of the Jupyter project.\nYou can launch the IPython shell on the command line with the ipython command (which similar to python case requires PATH configuration), and quit the shell with exit/exit()/quit/quit() commands.\nThe reference Python kernel provided by IPython is called ipykernel. With ipykernel you may create and maintain multiple kernels.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/concepts.html#jupyter",
    "href": "contents/pyconcepts/concepts.html#jupyter",
    "title": "4  Some Hard Python concepts",
    "section": "4.5 Jupyter",
    "text": "4.5 Jupyter\nJupyter projects contain many subprojects, which includes Jupyter User Interfaces. The Jupyter user interfaces offer a foundation of interactive computing environments where scientific computing, data science, and analytics can be performed using a wide range of programming languages. This includes Jupyter console, Jupyter qtconsole, and Jupyter notebook. Here we mainly focus on Jupyter notebook.\nJupyter notebooks are structured data that represent your code, metadata, content, and outputs. When saved to disk, the notebook uses the extension .ipynb, and uses a JSON structure. After receiving the user input, the notebook communicates with the kernel using JSON messages sent over ZeroMQ sockets. The protocol used between the frontends and the kernel is described in Messaging in Jupyter.\nA kernel process can be connected to more than one frontend simultaneously. In this case, the different frontends will have access to the same variables.\nThis design was intended to allow easy development of different frontends based on the same kernel, but it also made it possible to support new languages in the same frontends, by developing kernels in those languages. The Jupyter Notebook Application has three main kernels: the ipykernel, irkernel and ijulia kernels. Actually the name of Jupyter comes from these three programming languages for data science: Julia, Python and R.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/concepts.html#multi-kernels-setup",
    "href": "contents/pyconcepts/concepts.html#multi-kernels-setup",
    "title": "4  Some Hard Python concepts",
    "section": "4.6 Multi-kernels setup",
    "text": "4.6 Multi-kernels setup\nThis section is mainly following the official document.\nTo install one IPython kernel, you may use conda or pip to install ipykernel in the environment. If you want to have multiple IPython kernels for different virtualenvs or conda environments, you will need to specify unique names for the kernelspecs.\n\nActivate the environment you want.\n\nconda activate myenv\n\nInstall the kernel in the environment.\n\nconda install jupyter\npython -m ipykernel install --user --name myenv --display-name \"Python (myenv)\"\n--user means that the kernel is installed in the user’s folder instead of a system folder, and it can be removed. The --name value (in this case it is myenv) is used by Jupyter internally. These commands will overwrite any existing kernel with the same name. --display-name is what you see in the notebook menus.\n\nYou could use the command to find all kernels installed in your system.\n\njupyter kernelspec list\nAvailable kernels are shown, as well as the path to the kernel configuration file kernel.json. The most important configuration is the path to the Python interpreter executatable file.\n\n\nkernel.json\n\n{\n \"argv\": [\n  \"C:\\\\Users\\\\Xinli\\\\anaconda3\\\\envs\\\\myenv\\\\python.exe\",\n  \"-m\",\n  \"ipykernel_launcher\",\n  \"-f\",\n  \"{connection_file}\"\n ],\n \"display_name\": \"Python (3.10)\",\n \"language\": \"python\",\n \"metadata\": {\n  \"debugger\": true\n }\n}\n\n\nThere is a possibility that Jupyter cannot find the kernel you create in a conda environment. In this case you may want to try nb_conda_kernels. This is a tool to enable a Jupyter notebook in one conda environment to access kernels found in other environments. It should be installed in the environment from which you run Jupyter Notebook or JupyterLab. This might be your base conda environment, but it need not be. After you finish installation, you may use jupyter kernelspec list to check whether it works.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Some Hard Python concepts</span>"
    ]
  },
  {
    "objectID": "contents/tools/re.html",
    "href": "contents/tools/re.html",
    "title": "6  Regular expression",
    "section": "",
    "text": "Regular expressions provide a flexible way to search or match string patterns in text. A single expression, commonly called a regex, is a string formed according to the regular expression language. Python’s built-in re module is responsible for applying regular expressions to strings.\nFor details of the regular expression language in Python, please read the official documents from here. There are also many great websites for learning regex. This is one example.\nWe will briefly mentioned a few rules here.\n\n.: matches any character except a newline.\n\\d: matches any digit. It is the same as [0-9].\n\\D: matches any characters that are NOT \\d. It is the same as [^0-9].\n\\w: matches any alphabatic or numeric character. It is the same as [a-zA-Z0-9_].\n\\W: matches any characters that are NOT \\w.\n\\s: matches any whitespaces. It is the same as [\\t\\n\\r\\f\\v].\n\\S: mathces any characters that are not \\s.\n\\A: matches the start of the string.\n\\Z: matches the end of the string.\n*: Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible.\n+: Causes the resulting RE to match 1 or more repetitions of the preceding RE, as many repetitions as are possible.\n?: Causes the resulting RE to match 0 or 1 repetitions of the preceding RE.\n*?, +?, ??: The *, +, and ? qualifiers are all greedy; they match as much text as possible. Adding ? after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched.\n{m}: Specifies that exactly m copies of the previous RE should be matched.\n{m,n}: Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible.\n{m,n}?: Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible.\n[]: Used to indicate a set of characters.\n(): set groups.\n\n\n\n\n\n\n\nNote\n\n\n\nTo search multiple characters simutanously, you may use []. For example, [abc] means either a or b or c. However, [] doesn’t recognize special characters, so [\\s|\\w] means either \\ or s or \\ or w, instead of the pattern \\s or \\w.\nTo search such a pattern, you may use (|). For example, (\\s|\\w) means either \\s or \\w satisfies the pattern.\n\n\n\nExample 6.1  \n\nimport re\ntext = \"foo bar\\t baz \\tqux\"\npattern = '\\s+'\nregex = re.compile(pattern)\nregex.split(text)\n\n['foo', 'bar', 'baz', 'qux']\n\n\n\n\n.match()\n.search()\n.findall()\n.split()\n.sub()\n\nWe can use () to specify groups, and use .groups() to get access to the results.\n\nExample 6.2  \n\nimport re\npattern = r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,4})'\nregex = re.compile(pattern, flags=re.IGNORECASE)\nm = regex.match('wesm@bright.net')\nm.groups()\n\n('wesm', 'bright', 'net')\n\n\n\nTo use regex to DataFrame and Series, you may directly apply .match, .findall, .replace after .str, with the regex pattern as one of the arguments.\n.extract is a method that is not from re. It is used to extract the matched groups and make them as a DataFrame.\n\nExample 6.3  \n\nimport pandas as pd\nimport numpy as np\nmnames = ['movie_id', 'title', 'genres']\nmovies = pd.read_table('../assests/datasets/movies.dat', sep='::',\n                       header=None, names=mnames, engine=\"python\",\n                       encoding='ISO-8859-1')\n\npattern = r'([a-zA-Z0-9_\\s,.?:;\\']+)\\((\\d{4})\\)'\nmovies = movies.join(movies.title.str.extract(pattern).rename(columns={0: 'movie title', 1: 'year'}))\n\n\n\n\nExercise 6.1 (Regular expressions) Please use regular expressions to finish the following tasks.\n\nMatch a string that has an a followed by zero or more b’s.\nMatch a string that has an a followed by one or more b’s.\nMatch a string that has an a followed by zero or one b.\nMatch a string that has an a followed by three b’s.\n\n\n\nExercise 6.2 (More regex) Find all words starting with a or e in a given string:\n\ntext = \"The following example creates an ArrayList with a capacity of 50 elements. Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly.\"\n\n\n\nExercise 6.3 (More regex) Write a Python code to extract year, month and date from a url1:\n\nurl1= \"https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/\"\n\n\n\nExercise 6.4 (More regex) Please use regex to parse the following str to create a dictionary.\n\ntext = r'''\n{\n    name: Firstname Lastname;\n    age: 100;\n    salary: 10000 \n}\n'''\n\n\n\nExercise 6.5 Consider the following DataFrame.\n\ndata = [['Evert van Dijk', 'Carmine-pink, salmon-pink streaks, stripes, flecks.  Warm pink, clear carmine pink, rose pink shaded salmon.  Mild fragrance.  Large, very double, in small clusters, high-centered bloom form.  Blooms in flushes throughout the season.'],\n        ['Every Good Gift', 'Red.  Flowers velvety red.  Moderate fragrance.  Average diameter 4\".  Medium-large, full (26-40 petals), borne mostly solitary bloom form.  Blooms in flushes throughout the season.'], \n        ['Evghenya', 'Orange-pink.  75 petals.  Large, very double bloom form.  Blooms in flushes throughout the season.'], \n        ['Evita', 'White or white blend.  None to mild fragrance.  35 petals.  Large, full (26-40 petals), high-centered bloom form.  Blooms in flushes throughout the season.'],\n        ['Evrathin', 'Light pink. [Deep pink.]  Outer petals white. Expand rarely.  Mild fragrance.  35 to 40 petals.  Average diameter 2.5\".  Medium, double (17-25 petals), full (26-40 petals), cluster-flowered, in small clusters bloom form.  Prolific, once-blooming spring or summer.  Glandular sepals, leafy sepals, long sepals buds.'],\n        ['Evita 2', 'White, blush shading.  Mild, wild rose fragrance.  20 to 25 petals.  Average diameter 1.25\".  Small, very double, cluster-flowered bloom form.  Blooms in flushes throughout the season.']]\n  \ndf = pd.DataFrame(data, columns = ['NAME', 'BLOOM']) \ndf \n\n\n\n\n\n\n\n\nNAME\nBLOOM\n\n\n\n\n0\nEvert van Dijk\nCarmine-pink, salmon-pink streaks, stripes, fl...\n\n\n1\nEvery Good Gift\nRed. Flowers velvety red. Moderate fragrance...\n\n\n2\nEvghenya\nOrange-pink. 75 petals. Large, very double b...\n\n\n3\nEvita\nWhite or white blend. None to mild fragrance....\n\n\n4\nEvrathin\nLight pink. [Deep pink.] Outer petals white. ...\n\n\n5\nEvita 2\nWhite, blush shading. Mild, wild rose fragran...\n\n\n\n\n\n\n\nPlease use regex methods to find all the () in each columns.\n\n\nExercise 6.6 From ser = pd.Series(['Apple', 'Orange', 'Plan', 'Python', 'Money']), find the words that contain at least 2 vowels.\n\n\nExercise 6.7 Please download the given file with sample emails, and use the following code to load the file and save it to a string content.\n\nwith open('../assests/datasets/test_emails.txt', 'r') as f:\n    content = f.read()\n\nPlease use regex to play with content.\n\nGet all valid email address in content, from both the header part or the body part.\nThere are two emails in content. Please get the sender’s email and the receiver’s email from content.\nPlease get the sender’s name.\nPlease get the subject of each email.\n\n\n\nExercise 6.8 Extract the valid emails from the series emails. The regex pattern for valid emails is provided as reference.\n\nimport pandas as pd\nemails = pd.Series(['buying books at amazom.com',\n                    'rameses@egypt.com',\n                    'matt@t.co',\n                    'narendra@modi.com'])\npattern = '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}'",
    "crumbs": [
      "Part III: Tools",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Regular expression</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/setup.html#sec-vscode",
    "href": "contents/pyconcepts/setup.html#sec-vscode",
    "title": "1  Python Setup",
    "section": "1.1 VS Code + Anaconda",
    "text": "1.1 VS Code + Anaconda\nNote that all the following steps are tested in Windows 10/11. If you use other operation systems please contact me.\n\nGo to Miniconda download page. Download and install Miniconda, and set things up in the following way.\n\n\n\n\n\n\n\nMore details.\n\n\n\n\n\n\nMiniconda is Python + conda, without any unessential packages. We choose this version because it is fast: the download package is small and easy to install.\nAfter you finish installing Miniconda, you may find the Anaconda Prompt (miniconda 3) from the start menu. Click it to start using it.\nYou may use the following command to install packages that is used in this course. More on this will be discussed later.\n\nconda install pandas numpy matplotlib seaborn\n\nIf you feel conda is slow, you may change the conda solver to be libmamba using the following command. It may be faster than the classic conda solver.\n\nconda config --set solver libmamba\n\nOnce these packages are installed, you may close the command prompt window and proceed to the next step.\n\n\n\n\n\n\n\n\n\n\nAn alternative way.\n\n\n\n\n\nIf you have enough time and space, you may go to Anaconda download page, download and install Anaconda.\nAnaconda is Miniconda + tons of preinstalled packages + many other tools that may not be used in this course.\n\n\n\n\nGo to VS Code download page. Download and install VS Code. Actually Anaconda contains one copy of VS Code. Here I just assume that some of you intall VS Code before Anaconda.\nWhen installing VS Code, you may accept all default settings. When installing Anaconda, please pay attention to the PATH setting.\n\n\n\n\n\n\nThe first box is unchecked by default. This setting is related to the ability to easily run Python code in Terminals. I recommend you to check it. If you don’t check it during this step, you may add it to the system environment variable PATH manually later.\n\nThe UI of VS Code looks as follows.\n\n\n\n\n\n\nPlease look at the fifth tab from the left sidebar. It is the Extension tab.\n\n\n\n\n\nPlease search for python and install the first Python extension from Microsoft. It will actually install five extensions. These are all we need for now.\n\nAfter all are installed, go to the first Explorer tab on the left side bar, and Open Folder. This is the working directory for your project.\n\n\n\n\n\n\nChoose one folder and start a new .py file.\n\n\n\n\n\n\nIf everything is setup correctly, you may see the Python version and environment name at the right lower corner. In our case the environment name is base. We will need it in the future.\n\n\n\n\n\n\nNote that we are not looking at the Python for Language Mode. If you see Select Interpreter there, it means that VS Code doesn’t find your Python interpreter. Please restart VS Code or select it manually, or check whether Anaconda is installed correctly.\n\n\n\n\n\nTo check whether everything is setup correctly, please run the following tests.\n\nUse ctrl+shift+p to open the Command Palette, type “Jupyter: Create Interactive Window” and press enter to open the Jupyter interactive window.\n\n\n\n\n\n\nIf the interactive window starts and you see the loading infomation of your kernel as follows, especially you see the environment name on the right upper corner, then you get everything correctly. However we will still do more tests.\n\n\n\n\n\n\nIn the window type import numpy as np to test whether you are able to import packages. If you don’t see any error messages then it means good.\n\n\n\n\n\n\n\nIn the editor window, type import numpy as np and right click the body to choose Run Current File in Interactive Window, and see whether it runs in interactive window.\n\n\n\n\n\n\n\nOpen the terminal. Please use Command Prompt instead of Powershell. Activate the conda environment by type the command conda activate base in the example above. Please change the name to match your own environment. If conda cannot be recognized, please register Python and Anaconda to the system environment path. Please see the next Appendix for details.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Setup</span>"
    ]
  },
  {
    "objectID": "contents/pyconcepts/setup.html#sec-googlecolab",
    "href": "contents/pyconcepts/setup.html#sec-googlecolab",
    "title": "1  Python Setup",
    "section": "1.2 Google Colab",
    "text": "1.2 Google Colab\nGoogle Colab is a product from Google Research, that allows anybody to write and execute arbitrary Python code through the browser, and is especially well suited to machine learning, data analysis and education.\nHere is the link to Google Colab. To use it you should have a Google account. Otherwise it is very simple to start, since a lot of packages for our course are already installed.\n\n1.2.1 Install packages\nIf you would like to install more packages, you can type the following code in a code cell and execute it.\n%pip install &lt;pkg name&gt;\n%conda install &lt;pkg name&gt;\nThe drawback here is that Google Colab can only stay for 24 hours. After that, all additionaly installed packages will be earsed. However you may put the installation code mentioned above at the beginning of your notebook and these packages will be installed every time you run the notebook.\n\n\n1.2.2 Upload files\nYou may directly upload files to the working directory of Google Colab. This has to be done in the browser. When working with these files, you may just use relative paths.\nThe drawback here is that Google Colab can only stay for 24 hours. After that, although your .ipynb files will be stores, all other files will be earsed.\n\n\n1.2.3 Mount Google Drive\nOne way to let the uploaded files stay in cloud is to upload them to Google Drive, and then load your Google Drive contents from Google Colab.\nGoole Drive is a cloud storage service provided by Google. When you register a Google account you will be automatically assigned a Google Drive account. You may get access to it from this link.\nHere are the steps to mount Google Drive:\n\nUpload your files to your Google Drive.\nRun the following codes in Colab code cells before you are loading the uploaded files:\n\n\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\n\n\nA window pop up asking you about the permission. Authorize and the drive is mounted.\nTo work in directories, the most popular commands are\n\n%ls: list all files and folders in the working directory.\n%cd + folder name: Get into a specific folder.\n%cd..: Get into the parent folder. Then use these commands to find the files your just uploaded.\n\nFinally you may directly get access to those files just like they are in the working directory.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Setup</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Miscs for Data Science",
    "section": "",
    "text": "Preface\nThis is the lecture notes for STAT 2304 Programming languages for Data Science Fall 2023 at ATU. If you have any comments/suggetions/concerns about the notes please contact me at xxiao@atu.edu.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Miscs for Data Science",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "contents/pyconcepts/path.html",
    "href": "contents/pyconcepts/path.html",
    "title": "2  Environemnt Variable PATH",
    "section": "",
    "text": "Here are the steps to edit the system environment variables in Windows 10/11.\n\nFirst in the start menu search for Edit the system environment variables.\n\n\n\n\n\n\n\nThen click the Environment Variables... button at the right lower corner.\n\n\n\n\n\n\n\nFind the Path variable in either the upper window or the lower window. Use which one depends on whether you want to register the variable for the user or for the machine. In this example I add for the user.\n\n\n\n\n\n\n\nFinally double click the variable and add the following path to it. You need to make changes according to your installation. I recommend you to locate your Anaconda installation first to get the path.",
    "crumbs": [
      "Part I: Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Environemnt Variable `PATH`</span>"
    ]
  }
]